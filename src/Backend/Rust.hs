{-# LANGUAGE OverloadedStrings #-}

module Backend.Rust (generateRustCode) where

import qualified Convex.Action.Parser as Action
import qualified Convex.Parser as P
import qualified Convex.Schema.Parser as Schema
import Data.Char (isUpper, toLower, toUpper)
import Data.List (intercalate, isPrefixOf, nub, sort)
import qualified Data.Map as Map

-- | A map from a sorted list of literal strings (a "signature") to the name of the enum constant.
type UnionSignatureMap = Map.Map [String] String

-- | Top-level function to generate the complete Rust module source.
generateRustCode :: P.ParsedProject -> String
generateRustCode project =
  let unifiedProject = unifyProjectTypes project
   in unlines
        [ "#![allow(dead_code)]",
          "// Generated by the Palaba code generator. DO NOT EDIT.",
          "// Save this file as, for example, `src/convex_api.rs`",
          "// and then add `pub mod convex_api;` to your `src/lib.rs` or `src/main.rs`.",
          "//",
          "// Make sure your `Cargo.toml` contains the following dependencies:",
          "// convex = \"0.1.3\"",
          "// serde = { version = \"1.0\", features = [\"derive\"] }",
          "// serde_json = \"1.0\"",
          "// thiserror = \"1.0\"",
          "// anyhow = \"1.0\"",
          "",
          generateRustModuleContent unifiedProject
        ]

-- | Pre-processes the parsed project to replace anonymous unions with named references.
unifyProjectTypes :: P.ParsedProject -> P.ParsedProject
unifyProjectTypes project =
  let unionMap = buildUnionSignatureMap (P.ppConstants project)
   in project {P.ppFunctions = map (unifyFunctionTypes unionMap) (P.ppFunctions project)}
  where
    buildUnionSignatureMap :: Map.Map String Schema.ConvexType -> UnionSignatureMap
    buildUnionSignatureMap constants =
      Map.fromList
        [ (sort $ map Schema.getLiteralString literals, name)
        | (name, Schema.VUnion literals) <- Map.toList constants,
          all Schema.isLiteral literals
        ]

    unifyFunctionTypes :: UnionSignatureMap -> Action.ConvexFunction -> Action.ConvexFunction
    unifyFunctionTypes unionMap func =
      func
        { Action.funcArgs = map (unifyArgType unionMap) (Action.funcArgs func),
          Action.funcReturn = unifyTypeRecursively unionMap (Action.funcReturn func)
        }

    unifyArgType :: UnionSignatureMap -> (String, Schema.ConvexType) -> (String, Schema.ConvexType)
    unifyArgType unionMap (argName, argType) =
      (argName, unifyTypeRecursively unionMap argType)

    -- This new recursive function traverses the entire type structure.
    unifyTypeRecursively :: UnionSignatureMap -> Schema.ConvexType -> Schema.ConvexType
    unifyTypeRecursively unionMap u@(Schema.VUnion literals)
      | all Schema.isLiteral literals =
          let signature = sort $ map Schema.getLiteralString literals
           in case Map.lookup signature unionMap of
                Just refName -> Schema.VReference refName
                Nothing -> u
      | otherwise = u
    unifyTypeRecursively unionMap (Schema.VObject fields) =
      Schema.VObject $ map (\(name, t) -> (name, unifyTypeRecursively unionMap t)) fields
    unifyTypeRecursively unionMap (Schema.VArray inner) =
      Schema.VArray $ unifyTypeRecursively unionMap inner
    unifyTypeRecursively unionMap (Schema.VOptional inner) =
      Schema.VOptional $ unifyTypeRecursively unionMap inner
    unifyTypeRecursively _ otherType = otherType -- Base cases

-- | Generates the entire content for a single Rust module file.
generateRustModuleContent :: P.ParsedProject -> String
generateRustModuleContent project =
  let (nestedFromFuncs, functionCode) = generateAllFunctions (P.ppFunctions project)
   in unlines
        [ "use convex::{ConvexClient, FunctionResult, Value};",
          "use serde::{Deserialize, Deserializer, Serialize, Serializer};",
          "use serde_json;",
          "use std::collections::BTreeMap;",
          "use std::fmt::{self, Display};",
          "use std::marker::PhantomData;",
          "",
          generateErrorEnum,
          generateIdStruct,
          generateApiStructAndImpl project functionCode,
          generateTypesModule project (nub nestedFromFuncs)
        ]

-- | Generates the idiomatic Rust error enum using `thiserror`.
generateErrorEnum :: String
generateErrorEnum =
  unlines
    [ "/// Represents all possible errors that can occur when interacting with the API.",
      "#[derive(thiserror::Error, Debug)]",
      "pub enum ApiError {",
      "    #[error(\"Convex client error: {0}\")]",
      "    ConvexClientError(String),",
      "",
      "    #[error(\"Convex function error: {0}\")]",
      "    ConvexFunctionError(String),",
      "",
      "    #[error(\"Failed to deserialize response: {0}\")]",
      "    DeserializationError(#[from] serde_json::Error),",
      "",
      "    #[error(\"Unexpected null value returned from a non-nullable function\")]",
      "    UnexpectedNullError,",
      "}",
      "",
      "impl From<anyhow::Error> for ApiError {",
      "    fn from(err: anyhow::Error) -> Self {",
      "        ApiError::ConvexClientError(err.to_string())",
      "    }",
      "}"
    ]

-- | Generates the strongly-typed `Id<T>` struct.
generateIdStruct :: String
generateIdStruct =
  unlines
    [ "/// A strongly-typed Convex document ID.",
      "#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]",
      "pub struct Id<T> {",
      "    id: String,",
      "    _phantom: PhantomData<T>,",
      "}",
      "",
      "impl<T> Default for Id<T> {",
      "    fn default() -> Self {",
      "        Self { id: String::new(), _phantom: PhantomData }",
      "    }",
      "}",
      "",
      "impl<T> Id<T> {",
      "    pub fn new(id: String) -> Self {",
      "        Self { id, _phantom: PhantomData }",
      "    }",
      "}",
      "",
      "impl<T> Display for Id<T> {",
      "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "        write!(f, \"{}\", self.id)",
      "    }",
      "}",
      "",
      "impl<T> Serialize for Id<T> {",
      "    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>",
      "    where",
      "        S: Serializer,",
      "    {",
      "        serializer.serialize_str(&self.id)",
      "    }",
      "}",
      "",
      "impl<'de, T> Deserialize<'de> for Id<T> {",
      "    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>",
      "    where",
      "        D: Deserializer<'de>,",
      "    {",
      "        let id = String::deserialize(deserializer)?;",
      "        Ok(Id::new(id))",
      "    }",
      "}",
      "",
      "impl<T> From<Id<T>> for Value {",
      "    fn from(val: Id<T>) -> Self {",
      "        Value::String(val.id)",
      "    }",
      "}"
    ]

-- | Generates the main `Api` struct and its `impl` block.
generateApiStructAndImpl :: P.ParsedProject -> String -> String
generateApiStructAndImpl project functionCode =
  unlines
    [ "/// The main API client for interacting with your Convex deployment.",
      "pub struct Api {",
      "    /// Escape hatch, gives access to the underlying Convex client.",
      "    pub client: ConvexClient,",
      "}",
      "",
      "impl Api {",
      "    /// Creates a new API client, wrapping the official Convex client.",
      "    pub fn new(client: ConvexClient) -> Self {",
      "        Self { client }",
      "    }",
      "",
      functionCode,
      "}"
    ]

-- | Generates all the API function wrappers as methods on the `Api` struct.
generateAllFunctions :: [Action.ConvexFunction] -> ([String], String)
generateAllFunctions funcs =
  let results = map generateFunction funcs
   in (concatMap fst results, unlines $ map snd results)

-- | Generates a single async Rust function for a Convex function.
generateFunction :: Action.ConvexFunction -> ([String], String)
generateFunction func =
  let funcName = Action.funcName func
      (argSignature, nestedFromArgs) = generateArgSignature funcName (Action.funcArgs func)
      funcNameSnake = toSnakeCase funcName
      (returnHint, isNullable, nestedFromReturn) = getReturnType funcName (Action.funcReturn func)
      handlerCall = case Action.funcType func of
        Action.Query -> "query"
        Action.Mutation -> "mutation"
        Action.Action -> "action"
      fullFuncPath = Action.funcPath func ++ ":" ++ funcName
      btreemapConstruction = generateBTreeMap (Action.funcArgs func)
      returnHandling = generateReturnHandling returnHint isNullable
      funcCode =
        unlines
          [ "    /// Wraps the `" ++ fullFuncPath ++ "` " ++ show (Action.funcType func) ++ ".",
            "    pub async fn " ++ funcNameSnake ++ "(&mut self, " ++ argSignature ++ ") -> Result<" ++ returnHint ++ ", ApiError> {",
            btreemapConstruction,
            "        let result = self.client." ++ handlerCall ++ "(\"" ++ fullFuncPath ++ "\", args).await?;",
            "        " ++ returnHandling,
            "    }"
          ]
   in (nestedFromArgs ++ nestedFromReturn, funcCode)

-- | Generates the `types` module containing all generated structs and enums.
generateTypesModule :: P.ParsedProject -> [String] -> String
generateTypesModule project nestedFromFuncs =
  let (tableCode, nestedFromTables) = generateAllTables (P.ppSchema project)
      (constantsCode, nestedFromConstants) = generateAllConstants (P.ppConstants project)
      allNestedCode = nub (nestedFromTables ++ nestedFromConstants ++ nestedFromFuncs)
   in unlines
        [ "pub mod types {",
          "    use super::*;",
          "",
          tableCode,
          constantsCode,
          unlines allNestedCode,
          "}"
        ]

generateAllTables :: Schema.Schema -> (String, [String])
generateAllTables (Schema.Schema tables) =
  let (tableCodes, nested) = unzip $ map generateTableStruct tables
   in (unlines tableCodes, concat nested)

generateTableStruct :: Schema.Table -> (String, [String])
generateTableStruct table =
  let className = toPascalCase (Schema.tableName table) ++ "Doc"
      (fieldLines, nestedFromFields) = unzip $ map (generateField className) (Schema.tableFields table)
   in ( unlines
          [ "    #[derive(Default, Serialize, Deserialize, Debug, Clone, PartialEq)]",
            "    pub struct " ++ className ++ " {",
            "        #[serde(default)]",
            "        pub _id: Id<" ++ className ++ ">,",
            "        #[serde(default)]",
            "        #[serde(rename = \"_creationTime\")]",
            "        pub creation_time: f64,",
            unlines fieldLines,
            "    }"
          ],
        concat nestedFromFields
      )

generateAllConstants :: Map.Map String Schema.ConvexType -> (String, [String])
generateAllConstants constants =
  let (constCodes, nested) = unzip $ map (uncurry generateConstant) (Map.toList constants)
   in (unlines constCodes, concat nested)

generateConstant :: String -> Schema.ConvexType -> (String, [String])
generateConstant name u@(Schema.VUnion literals)
  | all Schema.isLiteral literals =
      let enumName = toPascalCase name
          variantNames = map Schema.getLiteralString literals
          buildVariantLines [] = []
          buildVariantLines (first : rest) =
            ("        #[default]\n        #[serde(rename = \"" ++ first ++ "\")]\n        " ++ toPascalCase first ++ ",")
              : map (\v -> "        #[serde(rename = \"" ++ v ++ "\")]\n        " ++ toPascalCase v ++ ",") rest
          code =
            unlines
              [ "    #[derive(Default, Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]",
                "    pub enum " ++ enumName ++ " {",
                unlines $ buildVariantLines variantNames,
                "    }"
              ]
       in (code, [])
  | otherwise =
      let (rustTypeName, nested) = toRustType name u
       in ("    pub type " ++ toPascalCase name ++ " = " ++ rustTypeName ++ ";", nested)
generateConstant name t =
  let (rustTypeName, nested) = toRustType name t
   in ("    pub type " ++ toPascalCase name ++ " = " ++ rustTypeName ++ ";", nested)

-- | Generates a single field line for a Rust struct.
generateField :: String -> Schema.Field -> (String, [String])
generateField nameHint field =
  let fieldNameSnake = toSnakeCase (Schema.fieldName field)
      (rustType, nested) = toRustType (nameHint ++ capitalize (Schema.fieldName field)) (Schema.fieldType field)
      serdeRename = if fieldNameSnake /= Schema.fieldName field then "#[serde(rename = \"" ++ Schema.fieldName field ++ "\")]\n        " else ""
      -- Build the serde attributes string
      serdeAttrs =
        let defaultAttr = "default"
            skipAttr =
              if needsOptionalWrapper (Schema.fieldType field)
                then Just "skip_serializing_if = \"Option::is_none\""
                else Nothing
            allAttrs = case skipAttr of
              Just s -> [defaultAttr, s]
              Nothing -> [defaultAttr]
         in "#[serde(" ++ intercalate ", " allAttrs ++ ")]"
      fieldLine = "        " ++ serdeRename ++ serdeAttrs ++ "\n        pub " ++ fieldNameSnake ++ ": " ++ rustType ++ ","
   in (fieldLine, nested)

-- | Helper to generate the function signature's arguments.
generateArgSignature :: String -> [(String, Schema.ConvexType)] -> (String, [String])
generateArgSignature funcName args =
  let results = map (\(n, t) -> toRustType (funcName ++ capitalize n) t) args
      sigParts = zipWith (\(n, _) (ty, _) -> toSnakeCase n ++ ": " ++ toRustBorrowType ty) args results
      nestedModels = concatMap snd results
   in (intercalate ", " sigParts, nestedModels)

-- | Helper to generate the BTreeMap construction logic.
generateBTreeMap :: [(String, Schema.ConvexType)] -> String
generateBTreeMap [] = "        let args = BTreeMap::new();"
generateBTreeMap args =
  let buildStmts (name, convexType) =
        let varName = toSnakeCase name
         in if isComplexType convexType
              then -- For complex types, use try_from and handle potential errors
                "        args.insert(\"" ++ name ++ "\".to_string(), Value::try_from(serde_json::to_value(" ++ varName ++ ")?)?);"
              else -- For simple types, From is implemented directly
                "        args.insert(\"" ++ name ++ "\".to_string(), Value::from(" ++ toClonedValue varName convexType ++ "));"
   in unlines
        [ "        let mut args = BTreeMap::new();",
          unlines $ map buildStmts args
        ]

-- | Determines if a ConvexType needs complex serialization via serde_json.
isComplexType :: Schema.ConvexType -> Bool
isComplexType (Schema.VObject _) = True
isComplexType (Schema.VArray _) = True
isComplexType (Schema.VUnion _) = True -- All unions serialize via JSON for simplicity.
isComplexType (Schema.VReference _) = True -- References are complex types.
isComplexType (Schema.VAny) = True -- Any type can be arbitrary, so we treat it as complex.
isComplexType _ = False

-- | Creates the correct clone/copy expression for simple types.
toClonedValue :: String -> Schema.ConvexType -> String
toClonedValue varName (Schema.VString) = varName ++ ".to_string()" -- for &str
toClonedValue varName t
  | isPassedByCopy t = varName
  | otherwise = varName ++ ".clone()"

-- | Checks if a type is a simple copy type in Rust.
isPassedByCopy :: Schema.ConvexType -> Bool
isPassedByCopy Schema.VNumber = True
isPassedByCopy Schema.VBoolean = True
isPassedByCopy _ = False

-- | Helper to get the return type information.
getReturnType :: String -> Schema.ConvexType -> (String, Bool, [String])
getReturnType funcName rt =
  let (baseType, nested) = toRustType (funcName ++ "Return") rt
      isNullable = needsOptionalWrapper rt
   in if baseType == "()"
        then ("()", False, nested)
        else (baseType, isNullable, nested)

-- | Generates the logic for handling the return value from Convex.
generateReturnHandling :: String -> Bool -> String
generateReturnHandling "()" _ =
  unlines
    [ "        match result {",
      "            FunctionResult::Value(_) => Ok(()),",
      "            FunctionResult::ErrorMessage(s) => Err(ApiError::ConvexFunctionError(s)),",
      "            FunctionResult::ConvexError(err) => Err(ApiError::ConvexClientError(err.to_string())),",
      "        }"
    ]
generateReturnHandling _ isNullable =
  if isNullable
    then
      unlines
        [ "        match result {",
          "            FunctionResult::Value(val) => Ok(serde_json::from_value(val.into())?),",
          "            FunctionResult::ErrorMessage(s) => Err(ApiError::ConvexFunctionError(s)),",
          "            FunctionResult::ConvexError(err) => Err(ApiError::ConvexClientError(err.to_string())),",
          "        }"
        ]
    else
      unlines
        [ "        match result {",
          "            FunctionResult::Value(Value::Null) => Err(ApiError::UnexpectedNullError),",
          "            FunctionResult::Value(val) => Ok(serde_json::from_value(val.into())?),",
          "            FunctionResult::ErrorMessage(s) => Err(ApiError::ConvexFunctionError(s)),",
          "            FunctionResult::ConvexError(err) => Err(ApiError::ConvexClientError(err.to_string())),",
          "        }"
        ]

-- | Core recursive function to generate Rust types from the AST.
toRustType :: String -> Schema.ConvexType -> (String, [String])
toRustType nameHint typ = case typ of
  Schema.VString -> ("String", [])
  Schema.VNumber -> ("f64", [])
  Schema.VBoolean -> ("bool", [])
  Schema.VAny -> ("serde_json::Value", [])
  Schema.VNull -> ("()", []) -- Placeholder, handled by Option
  Schema.VId t -> ("Id<types::" ++ toPascalCase t ++ "Doc>", [])
  Schema.VArray inner ->
    let (innerType, nested) = toRustType nameHint inner
     in ("Vec<" ++ innerType ++ ">", nested)
  Schema.VOptional inner ->
    let (innerType, nested) = toRustType nameHint inner
     in ("Option<" ++ innerType ++ ">", nested)
  Schema.VObject fields ->
    let className = toPascalCase nameHint ++ "Object"
        (fieldLines, nestedFields) = unzip $ map (generateField nameHint) (map (\(n, t) -> Schema.Field n t) fields)
        newModel =
          unlines
            [ "    #[derive(Default, Serialize, Deserialize, Debug, Clone, PartialEq)]",
              "    pub struct " ++ className ++ " {",
              unlines fieldLines,
              "    }"
            ]
     in ("types::" ++ className, concat nestedFields ++ [newModel])
  Schema.VUnion types ->
    let nonNullTypes = filter (/= Schema.VNull) types
     in case nonNullTypes of
          [] -> ("Option<()>", [])
          [singleType] ->
            let (innerType, nested) = toRustType nameHint singleType
             in ("Option<" ++ innerType ++ ">", nested)
          _ ->
            if all Schema.isLiteral nonNullTypes && not (null nonNullTypes)
              then
                let enumName = toPascalCase nameHint ++ "Enum"
                    variantNames = map Schema.getLiteralString nonNullTypes
                    buildVariantLines [] = []
                    buildVariantLines (first : rest) =
                      ("        #[default]\n        #[serde(rename = \"" ++ first ++ "\")]\n        " ++ toPascalCase first ++ ",")
                        : map (\v -> "        #[serde(rename = \"" ++ v ++ "\")]\n        " ++ toPascalCase v ++ ",") rest
                    newEnum =
                      unlines
                        [ "    #[derive(Default, Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]",
                          "    pub enum " ++ enumName ++ " {",
                          unlines $ buildVariantLines variantNames,
                          "    }"
                        ]
                 in ("types::" ++ enumName, [newEnum])
              else ("serde_json::Value", []) -- Fallback for complex unions
  Schema.VLiteral s -> (toPascalCase nameHint, [])
  Schema.VReference n -> ("types::" ++ toPascalCase n, [])
  Schema.VVoid -> ("()", [])

-- | Like toRustType, but for borrowed arguments in function signatures.
toRustBorrowType :: String -> String
toRustBorrowType rustType
  | rustType == "String" = "&str"
  | rustType == "f64" = "f64"
  | rustType == "bool" = "bool"
  | rustType == "serde_json::Value" = "&serde_json::Value"
  | "Id<" `isPrefixOf` rustType = "&" ++ rustType
  | "Vec<" `isPrefixOf` rustType = let inner = take (length rustType - 5) (drop 4 rustType) in "&[" ++ inner ++ "]"
  | "Option<" `isPrefixOf` rustType = let inner = take (length rustType - 8) (drop 7 rustType) in "Option<" ++ toRustBorrowType inner ++ ">"
  | otherwise = rustType -- Other types (enums) are passed by value

-- | Check if a field type should be wrapped in Option for serde attributes.
needsOptionalWrapper :: Schema.ConvexType -> Bool
needsOptionalWrapper (Schema.VOptional _) = True
needsOptionalWrapper (Schema.VUnion ts) = Schema.VNull `elem` ts
needsOptionalWrapper _ = False

-- | Converts a string to PascalCase.
toPascalCase :: String -> String
toPascalCase s = concatMap capitalize parts
  where
    parts = words $ map (\c -> if c == '_' then ' ' else c) s

capitalize :: String -> String
capitalize "" = ""
capitalize (c : cs) = toUpper c : cs

-- | Converts a string to snake_case.
toSnakeCase :: String -> String
toSnakeCase "" = ""
toSnakeCase (c : cs) = toLower c : go cs
  where
    go (c' : cs')
      | isUpper c' = '_' : toLower c' : go cs'
      | otherwise = c' : go cs'
    go "" = ""
