{-# LANGUAGE OverloadedStrings #-}

module Backend.Rust (generateRustCode) where

import qualified Convex.Action.Parser as Action
import qualified Convex.Parser as P
import qualified Convex.Schema.Parser as Schema
import Data.Char (isUpper, toLower, toUpper)
import Data.List (intercalate, isPrefixOf, nub, sort)
import qualified Data.Map as Map

-- | Top-level function to generate the complete Rust module source.
generateRustCode :: P.ParsedProject -> String
generateRustCode project =
  unlines
    [ "// Generated by the Palaba code generator. DO NOT EDIT.",
      "// Save this file as, for example, `src/convex_api.rs`",
      "// and then add `pub mod convex_api;` to your `src/lib.rs` or `src/main.rs`.",
      "//",
      "// Make sure your `Cargo.toml` contains the following dependencies:",
      "// convex = \"0.1.3\"",
      "// serde = { version = \"1.0\", features = [\"derive\"] }",
      "// serde_json = \"1.0\"",
      "// thiserror = \"1.0\"",
      "",
      generateRustModuleContent project
    ]

-- | Generates the entire content for a single Rust module file.
generateRustModuleContent :: P.ParsedProject -> String
generateRustModuleContent project =
  let (nestedFromFuncs, functionCode) = generateAllFunctions (P.ppFunctions project)
   in unlines
        [ "use convex::{ConvexClient, FunctionResult, Value};",
          "use serde::{Deserialize, Serialize};",
          "use std::collections::BTreeMap;",
          "use std::fmt::{self, Display};",
          "use std::marker::PhantomData;",
          "",
          generateErrorEnum,
          generateIdStruct,
          generateApiStructAndImpl project functionCode,
          generateTypesModule project (nub nestedFromFuncs)
        ]

-- | Generates the idiomatic Rust error enum using `thiserror`.
generateErrorEnum :: String
generateErrorEnum =
  unlines
    [ "/// Represents all possible errors that can occur when interacting with the API.",
      "#[derive(thiserror::Error, Debug)]",
      "pub enum ApiError {",
      "    #[error(\"Convex client error: {0}\")]",
      "    ConvexClientError(String),",
      "",
      "    #[error(\"Convex function error: {0}\")]",
      "    ConvexFunctionError(String),",
      "",
      "    #[error(\"Failed to deserialize response: {0}\")]",
      "    DeserializationError(#[from] serde_json::Error),",
      "",
      "    #[error(\"Unexpected null value returned from a non-nullable function\")]",
      "    UnexpectedNullError,",
      "}",
      "",
      "// We also need to tell our ApiError how to be created from a convex::ConvexError,",
      "// by converting it into an anyhow::Error first.",
      "impl From<anyhow::Error> for ApiError {",
      "    fn from(err: anyhow::Error) -> Self {",
      "        ApiError::ConvexClientError(err.to_string())",
      "    }",
      "}"
    ]

-- | Generates the strongly-typed `Id<T>` struct.
generateIdStruct :: String
generateIdStruct =
  unlines
    [ "/// A strongly-typed Convex document ID.",
      "#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]",
      "pub struct Id<T> {",
      "    id: String,",
      "    _phantom: PhantomData<T>,",
      "}",
      "",
      "impl<T> Id<T> {",
      "    pub fn new(id: String) -> Self {",
      "        Self { id, _phantom: PhantomData }",
      "    }",
      "}",
      "",
      "impl<T> Display for Id<T> {",
      "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {",
      "        write!(f, \"{}\", self.id)",
      "    }",
      "}",
      "",
      "impl<T> From<Id<T>> for Value {",
      "    fn from(val: Id<T>) -> Self {",
      "        Value::String(val.id)",
      "    }",
      "}"
    ]

-- | Generates the main `Api` struct and its `impl` block.
generateApiStructAndImpl :: P.ParsedProject -> String -> String
generateApiStructAndImpl project functionCode =
  unlines
    [ "/// The main API client for interacting with your Convex deployment.",
      "pub struct Api {",
      "    /// Escape hatch, gives access to the underlying Convex client.",
      "    pub client: ConvexClient,",
      "}",
      "",
      "impl Api {",
      "    /// Creates a new API client, wrapping the official Convex client.",
      "    pub fn new(client: ConvexClient) -> Self {",
      "        Self { client }",
      "    }",
      "",
      functionCode,
      "}"
    ]

-- | Generates all the API function wrappers as methods on the `Api` struct.
generateAllFunctions :: [Action.ConvexFunction] -> ([String], String)
generateAllFunctions funcs =
  let results = map generateFunction funcs
   in (concatMap fst results, unlines $ map snd results)

-- | Generates a single async Rust function for a Convex function.
generateFunction :: Action.ConvexFunction -> ([String], String)
generateFunction func =
  let (argSignature, nestedFromArgs) = generateArgSignature (Action.funcArgs func)
      funcNameSnake = toSnakeCase (Action.funcName func)
      (returnHint, isNullable, nestedFromReturn) = getReturnType (Action.funcName func) (Action.funcReturn func)
      handlerCall = case Action.funcType func of
        Action.Query -> "query"
        Action.Mutation -> "mutation"
        Action.Action -> "action"
      fullFuncPath = Action.funcPath func ++ ":" ++ Action.funcName func
      btreemapConstruction = generateBTreeMap (Action.funcArgs func)
      returnHandling = generateReturnHandling returnHint isNullable
      funcCode =
        unlines
          [ "    /// Wraps the `" ++ fullFuncPath ++ "` " ++ show (Action.funcType func) ++ ".",
            "    pub async fn " ++ funcNameSnake ++ "(&mut self, " ++ argSignature ++ ") -> Result<" ++ returnHint ++ ", ApiError> {",
            "        " ++ btreemapConstruction,
            "        let result_value = self.client." ++ handlerCall ++ "(\"" ++ fullFuncPath ++ "\", args).await?;",
            "        " ++ returnHandling,
            "    }"
          ]
   in (nestedFromArgs ++ nestedFromReturn, funcCode)

-- | Generates the `types` module containing all generated structs and enums.
generateTypesModule :: P.ParsedProject -> [String] -> String
generateTypesModule project nestedFromFuncs =
  unlines
    [ "pub mod types {",
      "    use super::*;",
      "",
      generateAllTables (P.ppSchema project),
      generateAllConstants (P.ppConstants project),
      unlines nestedFromFuncs,
      "}"
    ]

generateAllTables :: Schema.Schema -> String
generateAllTables (Schema.Schema tables) = unlines $ map generateTableStruct tables

generateTableStruct :: Schema.Table -> String
generateTableStruct table =
  let className = toPascalCase (Schema.tableName table) ++ "Doc"
      (fieldLines, _) = unzip $ map generateField (Schema.tableFields table)
   in unlines
        [ "    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]",
          "    pub struct " ++ className ++ " {",
          "        pub _id: Id<" ++ className ++ ">,",
          "        #[serde(rename = \"_creationTime\")]",
          "        pub creation_time: f64,",
          unlines fieldLines,
          "    }"
        ]

generateAllConstants :: Map.Map String Schema.ConvexType -> String
generateAllConstants = unlines . map (uncurry generateConstant) . Map.toList

generateConstant :: String -> Schema.ConvexType -> String
generateConstant name u@(Schema.VUnion literals)
  | all isLiteral literals =
      let enumName = toPascalCase name
          variantNames = map getLiteralString literals
       in unlines
            [ "    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]",
              "    pub enum " ++ enumName ++ " {",
              unlines $ map (\v -> "        #[serde(rename = \"" ++ v ++ "\")]\n        " ++ toPascalCase v ++ ",") variantNames,
              "    }"
            ]
  | otherwise =
      let (rustTypeName, nested) = toRustType name u
       in unlines $ nested ++ ["    pub type " ++ toPascalCase name ++ " = " ++ rustTypeName ++ ";"]
  where
    isLiteral (Schema.VLiteral _) = True
    isLiteral _ = False
    getLiteralString (Schema.VLiteral s) = s
    getLiteralString _ = ""
generateConstant name t =
  let (rustTypeName, nested) = toRustType name t
   in unlines $ nested ++ ["    pub type " ++ toPascalCase name ++ " = " ++ rustTypeName ++ ";"]

-- | Generates a single field line for a Rust struct.
generateField :: Schema.Field -> (String, [String])
generateField field =
  let fieldNameSnake = toSnakeCase (Schema.fieldName field)
      (rustType, nested) = toRustType (Schema.fieldName field) (Schema.fieldType field)
      serdeRename = if fieldNameSnake /= Schema.fieldName field then "#[serde(rename = \"" ++ Schema.fieldName field ++ "\")]\n        " else ""
      fieldLine =
        if needsOptionalWrapper (Schema.fieldType field)
          then "        " ++ serdeRename ++ "#[serde(skip_serializing_if = \"Option::is_none\")]\n        pub " ++ fieldNameSnake ++ ": " ++ rustType ++ ","
          else "        " ++ serdeRename ++ "pub " ++ fieldNameSnake ++ ": " ++ rustType ++ ","
   in (fieldLine, nested)

-- | Helper to generate the function signature's arguments.
generateArgSignature :: [(String, Schema.ConvexType)] -> (String, [String])
generateArgSignature args =
  let results = map (\(n, t) -> toRustType n t) args
      sigParts = zipWith (\(n, _) (ty, _) -> toSnakeCase n ++ ": " ++ toRustBorrowType ty) args results
      nestedModels = concatMap snd results
   in (intercalate ", " sigParts, nestedModels)

-- | Helper to generate the BTreeMap construction logic.
generateBTreeMap :: [(String, Schema.ConvexType)] -> String
generateBTreeMap [] = "let args = BTreeMap::new();"
generateBTreeMap args =
  let buildStmts (name, convexType) =
        let varName = toSnakeCase name
         in if isComplexType convexType
              then -- For complex types, use try_from and handle potential errors
                "        args.insert(\"" ++ name ++ "\".to_string(), Value::try_from(serde_json::to_value(" ++ varName ++ ")?)?);"
              else -- For simple types, From is implemented directly
                "        args.insert(\"" ++ name ++ "\".to_string(), Value::from(" ++ toClonedValue varName convexType ++ "));"
   in unlines
        [ "        let mut args = BTreeMap::new();",
          unlines $ map buildStmts args
        ]

-- | Determines if a ConvexType needs complex serialization via serde_json.
isComplexType :: Schema.ConvexType -> Bool
isComplexType (Schema.VObject _) = True
isComplexType (Schema.VArray _) = True
isComplexType (Schema.VUnion _) = True -- All unions serialize via JSON for simplicity.
isComplexType (Schema.VReference _) = True -- References are complex types.
isComplexType (Schema.VAny) = True -- Any type can be arbitrary, so we treat it as complex.
isComplexType _ = False

-- | Creates the correct clone/copy expression for simple types.
toClonedValue :: String -> Schema.ConvexType -> String
toClonedValue varName (Schema.VString) = varName ++ ".to_string()" -- for &str
toClonedValue varName t
  | isPassedByCopy t = varName
  | otherwise = varName ++ ".clone()"

-- | Checks if a type is a simple copy type in Rust.
isPassedByCopy :: Schema.ConvexType -> Bool
isPassedByCopy Schema.VNumber = True
isPassedByCopy Schema.VBoolean = True
isPassedByCopy _ = False

-- | Determines how to convert a Rust variable to a `convex::Value`.
toRustValueConversion :: String -> Schema.ConvexType -> String
toRustValueConversion varName (Schema.VId _) = "Value::from(" ++ varName ++ ".clone())"
toRustValueConversion varName (Schema.VOptional inner) = "match " ++ varName ++ " { Some(v) => " ++ toRustValueConversion "v" inner ++ ", None => Value::Null }"
toRustValueConversion varName (Schema.VObject _) = "Value::from(serde_json::to_value(" ++ varName ++ ").unwrap_or(Value::Null))"
toRustValueConversion varName (Schema.VArray _) = "Value::from(serde_json::to_value(" ++ varName ++ ").unwrap_or(Value::Null))"
toRustValueConversion varName (Schema.VUnion _) = "Value::from(serde_json::to_value(" ++ varName ++ ").unwrap_or(Value::Null))" -- Assumes enum
toRustValueConversion varName _ = "Value::from(" ++ varName ++ ".clone())"

-- | Helper to get the return type information.
getReturnType :: String -> Schema.ConvexType -> (String, Bool, [String])
getReturnType funcName rt =
  let (baseType, nested) = toRustType funcName rt
      isNullable = needsOptionalWrapper rt
   in if baseType == "()"
        then ("()", False, nested)
        else (baseType, isNullable, nested)

-- | Generates the logic for handling the return value from Convex.
generateReturnHandling :: String -> Bool -> String
generateReturnHandling "()" _ =
  unlines
    [ "        match result_value {",
      "            FunctionResult::Value(_) => Ok(()),",
      "            FunctionResult::ErrorMessage(s) => Err(ApiError::ConvexFunctionError(s)),",
      "            FunctionResult::ConvexError(err) => Err(ApiError::ConvexClientError(err.to_string())),",
      "        }"
    ]
generateReturnHandling _ isNullable@(True) =
  unlines
    [ "        match result_value {",
      "            FunctionResult::Value(val) => Ok(serde_json::from_value(val.into())?),",
      "            FunctionResult::ErrorMessage(s) => Err(ApiError::ConvexFunctionError(s)),",
      "            FunctionResult::ConvexError(err) => Err(ApiError::ConvexClientError(err.to_string())),",
      "        }"
    ]
generateReturnHandling _ isNullable@(False) =
  unlines
    [ "        match result_value {",
      "            FunctionResult::Value(Value::Null) => Err(ApiError::UnexpectedNullError),",
      "            FunctionResult::Value(val) => Ok(serde_json::from_value(val.into())?),",
      "            FunctionResult::ErrorMessage(s) => Err(ApiError::ConvexFunctionError(s)),",
      "            FunctionResult::ConvexError(err) => Err(ApiError::ConvexClientError(err.to_string())),",
      "        }"
    ]

-- | Core recursive function to generate Rust types from the AST.
toRustType :: String -> Schema.ConvexType -> (String, [String])
toRustType nameHint typ = case typ of
  Schema.VString -> ("String", [])
  Schema.VNumber -> ("f64", [])
  Schema.VBoolean -> ("bool", [])
  Schema.VAny -> ("serde_json::Value", [])
  Schema.VNull -> ("()", []) -- Placeholder, handled by Option
  Schema.VId t -> ("Id<types::" ++ toPascalCase t ++ "Doc>", [])
  Schema.VArray inner ->
    let (innerType, nested) = toRustType nameHint inner
     in ("Vec<" ++ innerType ++ ">", nested)
  Schema.VOptional inner ->
    let (innerType, nested) = toRustType nameHint inner
     in ("Option<" ++ innerType ++ ">", nested)
  Schema.VObject fields ->
    let className = toPascalCase (nameHint ++ "Object")
        (fieldLines, nestedFields) = unzip $ map generateField (map (\(n, t) -> Schema.Field n t) fields)
        newModel =
          unlines
            [ "    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]",
              "    pub struct " ++ className ++ " {",
              unlines fieldLines,
              "    }"
            ]
     in ("types::" ++ className, concat nestedFields ++ [newModel])
  Schema.VUnion types ->
    let nonNullTypes = filter (/= Schema.VNull) types
     in case nonNullTypes of
          [] -> ("Option<()>", [])
          [singleType] ->
            let (innerType, nested) = toRustType nameHint singleType
             in ("Option<" ++ innerType ++ ">", nested)
          _ -> (toPascalCase nameHint, []) -- Assumes it will be a generated enum or type alias
  Schema.VLiteral s -> (toPascalCase nameHint, [])
  Schema.VReference n -> ("types::" ++ toPascalCase n, [])
  Schema.VVoid -> ("()", [])

-- | Like toRustType, but for borrowed arguments in function signatures.
toRustBorrowType :: String -> String
toRustBorrowType rustType
  | rustType == "String" = "&str"
  | rustType == "f64" = "f64"
  | rustType == "bool" = "bool"
  | rustType == "Value" = "&Value"
  | "Id<" `isPrefixOf` rustType = "&" ++ rustType
  | "Vec<" `isPrefixOf` rustType = let inner = take (length rustType - 5) (drop 4 rustType) in "&[" ++ inner ++ "]"
  | "Option<" `isPrefixOf` rustType = let inner = take (length rustType - 8) (drop 7 rustType) in "Option<" ++ toRustBorrowType inner ++ ">"
  | otherwise = rustType -- Other types (enums) are passed by value

-- | Check if a field type should be wrapped in Option for serde attributes.
needsOptionalWrapper :: Schema.ConvexType -> Bool
needsOptionalWrapper (Schema.VOptional _) = True
needsOptionalWrapper (Schema.VUnion ts) = Schema.VNull `elem` ts
needsOptionalWrapper _ = False

-- | Converts a string to PascalCase.
toPascalCase :: String -> String
toPascalCase s = concatMap capitalize parts
  where
    parts = words $ map (\c -> if c == '_' then ' ' else c) s
    capitalize "" = ""
    capitalize (c : cs) = toUpper c : cs

-- | Converts a string to snake_case.
toSnakeCase :: String -> String
toSnakeCase "" = ""
toSnakeCase (c : cs) = toLower c : go cs
  where
    go (c' : cs')
      | isUpper c' = '_' : toLower c' : go cs'
      | otherwise = c' : go cs'
    go "" = ""
