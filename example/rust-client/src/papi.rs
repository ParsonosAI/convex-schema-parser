#![allow(dead_code)]
#![allow(non_snake_case)]
// Generated by the Palaba code generator. DO NOT EDIT.
// Save this file as, for example, `src/convex_api.rs`
// and then add `pub mod convex_api;` to your `src/lib.rs` or `src/main.rs`.
//
// Make sure your `Cargo.toml` contains the following dependencies:
// convex = "0.1.3"
// serde = { version = "1.0", features = ["derive"] }
// serde_json = "1.0"
// thiserror = "1.0"
// anyhow = "1.0"
// futures-util = "0.3"

use convex::{ConvexClient, FunctionResult, Value};
use futures_util::stream::Stream;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use serde_json;
use std::collections::BTreeMap;
use std::fmt::{self, Display};
use std::marker::PhantomData;
use std::pin::Pin;
use std::task::{Context, Poll};

/// Represents all possible errors that can occur when interacting with the API.
#[derive(thiserror::Error, Debug)]
pub enum ApiError {
    #[error("Convex client error: {0}")]
    ConvexClientError(String),
    #[error("Convex function error: {0}")]
    ConvexFunctionError(String),
    #[error("Failed to deserialize response: {0}")]
    DeserializationError(#[from] serde_json::Error),
    #[error("Unexpected null value returned from a non-nullable function")]
    UnexpectedNullError,
}
impl From<anyhow::Error> for ApiError {
    fn from(err: anyhow::Error) -> Self {
        ApiError::ConvexClientError(err.to_string())
    }
}

/// A strongly-typed Convex document ID.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Id<T> {
    id: String,
    _phantom: PhantomData<T>,
}
impl<T> Default for Id<T> {
    fn default() -> Self {
        Self {
            id: String::new(),
            _phantom: PhantomData,
        }
    }
}
impl<T> Id<T> {
    pub fn new(id: String) -> Self {
        Self {
            id,
            _phantom: PhantomData,
        }
    }
}
impl<T> Display for Id<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.id)
    }
}
impl<T> Serialize for Id<T> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.id)
    }
}
impl<'de, T> Deserialize<'de> for Id<T> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let id = String::deserialize(deserializer)?;
        Ok(Id::new(id))
    }
}
impl<T> From<Id<T>> for Value {
    fn from(val: Id<T>) -> Self {
        Value::String(val.id)
    }
}
impl<T> TryFrom<Value> for Id<T> {
    type Error = ApiError;
    fn try_from(value: Value) -> Result<Self, Self::Error> {
        if let Value::String(id) = value {
            Ok(Id::new(id))
        } else {
            Err(ApiError::ConvexClientError(
                "Expected a string for Id".to_string(),
            ))
        }
    }
}
impl<T> FromConvexValue for Id<T> {
    fn from_convex(value: Value) -> Result<Self, ApiError> {
        Id::try_from(value).map_err(ApiError::from)
    }
}

pub trait FromConvexValue: Sized {
    fn from_convex(value: Value) -> Result<Self, ApiError>;
}
impl FromConvexValue for bool {
    fn from_convex(value: Value) -> Result<Self, ApiError> {
        match value {
            Value::Boolean(b) => Ok(b),
            _ => Err(ApiError::ConvexClientError("Expected bool".into())),
        }
    }
}
impl FromConvexValue for i64 {
    fn from_convex(value: Value) -> Result<Self, ApiError> {
        match value {
            Value::Int64(i) => Ok(i),
            _ => Err(ApiError::ConvexClientError("Expected i64".into())),
        }
    }
}
impl FromConvexValue for i32 {
    fn from_convex(value: Value) -> Result<Self, ApiError> {
        match value {
            Value::Int64(i) => i
                .try_into()
                .map_err(|_| ApiError::ConvexClientError("i64 out of range for i32".into())),
            _ => Err(ApiError::ConvexClientError("Expected i64".into())),
        }
    }
}
impl FromConvexValue for f64 {
    fn from_convex(value: Value) -> Result<Self, ApiError> {
        match value {
            Value::Float64(f) => Ok(f),
            _ => Err(ApiError::ConvexClientError("Expected f64".into())),
        }
    }
}
impl FromConvexValue for f32 {
    fn from_convex(value: Value) -> Result<Self, ApiError> {
        match value {
            Value::Float64(f) => Ok(f as f32),
            _ => Err(ApiError::ConvexClientError("Expected f64".into())),
        }
    }
}
impl<T> FromConvexValue for Vec<T>
where
    T: FromConvexValue,
{
    fn from_convex(value: Value) -> Result<Self, ApiError> {
        match value {
            Value::Array(arr) => arr
                .into_iter()
                .map(T::from_convex)
                .collect::<Result<Vec<T>, ApiError>>(),
            _ => Err(ApiError::ConvexClientError("Expected array".into())),
        }
    }
}
impl<T> FromConvexValue for Option<T>
where
    T: FromConvexValue,
{
    fn from_convex(value: Value) -> Result<Self, ApiError> {
        match value {
            Value::Null => Ok(None),
            other => T::from_convex(other).map(Some),
        }
    }
}
impl FromConvexValue for Vec<u8> {
    fn from_convex(value: Value) -> Result<Self, ApiError> {
        match value {
            Value::Bytes(bytes) => Ok(bytes),
            _ => Err(ApiError::ConvexClientError("Expected bytes".into())),
        }
    }
}
impl FromConvexValue for String {
    fn from_convex(value: Value) -> Result<Self, ApiError> {
        match value {
            Value::String(s) => Ok(s),
            _ => Err(ApiError::ConvexClientError("Expected string".into())),
        }
    }
}
impl FromConvexValue for serde_json::Value {
    fn from_convex(value: Value) -> Result<Self, ApiError> {
        Ok(value.into())
    }
}

/// A type-safe, auto-deserializing stream of updates from a Convex query subscription.
#[derive(Debug)]
pub struct TypedSubscription<T> {
    raw_subscription: convex::QuerySubscription,
    _phantom: PhantomData<T>,
}
impl<T> Stream for TypedSubscription<T>
where
    T: FromConvexValue,
{
    type Item = Result<T, ApiError>;
    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let raw_sub_pin: Pin<&mut _> =
            unsafe { self.map_unchecked_mut(|s| &mut s.raw_subscription) };
        match raw_sub_pin.poll_next(cx) {
            Poll::Ready(Some(result)) => {
                let item = match result {
                    FunctionResult::Value(value) => T::from_convex(value),
                    FunctionResult::ErrorMessage(s) => Err(ApiError::ConvexFunctionError(s)),
                    FunctionResult::ConvexError(err) => {
                        Err(ApiError::ConvexClientError(err.to_string()))
                    }
                };
                Poll::Ready(Some(item))
            }
            Poll::Ready(None) => Poll::Ready(None),
            Poll::Pending => Poll::Pending,
        }
    }
}

pub struct Api {
    pub client: ConvexClient,
}
pub struct ListMessages<'a> {
    client: &'a mut ConvexClient,
}
pub struct SendMessage<'a> {
    client: &'a mut ConvexClient,
}
impl Api {
    pub fn new(client: ConvexClient) -> Self {
        Self { client }
    }
    pub fn send_message(&mut self) -> SendMessage<'_> {
        SendMessage {
            client: &mut self.client,
        }
    }
    pub fn list_messages(&mut self) -> ListMessages<'_> {
        ListMessages {
            client: &mut self.client,
        }
    }
}
impl<'a> ListMessages<'a> {
    /// Wraps the `listMessages:list` Query.
    pub async fn list(&mut self) -> Result<Vec<types::MessagesDoc>, ApiError> {
        let btmap = BTreeMap::new();
        let result = self.client.query("listMessages:list", btmap).await?;
        match result {
            FunctionResult::Value(Value::Null) => Err(ApiError::UnexpectedNullError),
            FunctionResult::Value(val) => Ok(FromConvexValue::from_convex(val.clone())?),
            FunctionResult::ErrorMessage(s) => Err(ApiError::ConvexFunctionError(s)),
            FunctionResult::ConvexError(err) => Err(ApiError::ConvexClientError(err.to_string())),
        }
    }
    /// Subscribes to the `listMessages:list` query.
    pub async fn subscribe_list(
        &mut self,
    ) -> Result<TypedSubscription<Vec<types::MessagesDoc>>, ApiError> {
        let btmap = BTreeMap::new();
        let raw_subscription = self.client.subscribe("listMessages:list", btmap).await?;
        Ok(TypedSubscription {
            raw_subscription,
            _phantom: PhantomData,
        })
    }
}
impl<'a> SendMessage<'a> {
    /// Wraps the `sendMessage:send` Mutation.
    pub async fn send(&mut self, author: &str, body: &str) -> Result<(), ApiError> {
        let mut btmap = BTreeMap::new();
        btmap.insert("author".to_string(), Value::from(author.to_string()));
        btmap.insert("body".to_string(), Value::from(body.to_string()));
        let result = self.client.mutation("sendMessage:send", btmap).await?;
        match result {
            FunctionResult::Value(_) => Ok(()),
            FunctionResult::ErrorMessage(s) => Err(ApiError::ConvexFunctionError(s)),
            FunctionResult::ConvexError(err) => Err(ApiError::ConvexClientError(err.to_string())),
        }
    }
}

pub mod types {
    use super::*;
    #[derive(Default, Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct MessagesDoc {
        #[serde(default)]
        pub _id: Id<MessagesDoc>,
        #[serde(default)]
        #[serde(rename = "_creationTime")]
        pub _creation_time: f64,
        #[serde(default)]
        pub author: String,
        #[serde(default)]
        pub body: String,
    }
    impl TryFrom<Value> for MessagesDoc {
        type Error = ApiError;
        fn try_from(value: Value) -> Result<Self, Self::Error> {
            let obj = match value {
                Value::Object(map) => map,
                _ => return Err(ApiError::ConvexClientError("Expected object".to_string())),
            };
            fn get__id(
                map: &BTreeMap<String, Value>,
                key: &str,
            ) -> Result<Id<types::MessagesDoc>, ApiError> {
                match map.get(key) {
                    Some(v) => Ok(FromConvexValue::from_convex(v.clone())?),
                    _ => {
                        return Err(ApiError::ConvexClientError(format!(
                            "Expected field (Id<types::MessagesDoc>) '{}' not found",
                            key
                        )))
                    }
                }
            }
            fn get__creation_time(
                map: &BTreeMap<String, Value>,
                key: &str,
            ) -> Result<f64, ApiError> {
                match map.get(key) {
                    Some(v) => Ok(FromConvexValue::from_convex(v.clone())?),
                    _ => {
                        return Err(ApiError::ConvexClientError(format!(
                            "Expected field (f64) '{}' not found",
                            key
                        )))
                    }
                }
            }
            fn get_author(map: &BTreeMap<String, Value>, key: &str) -> Result<String, ApiError> {
                match map.get(key) {
                    Some(v) => Ok(FromConvexValue::from_convex(v.clone())?),
                    _ => {
                        return Err(ApiError::ConvexClientError(format!(
                            "Expected field (String) '{}' not found",
                            key
                        )))
                    }
                }
            }
            fn get_body(map: &BTreeMap<String, Value>, key: &str) -> Result<String, ApiError> {
                match map.get(key) {
                    Some(v) => Ok(FromConvexValue::from_convex(v.clone())?),
                    _ => {
                        return Err(ApiError::ConvexClientError(format!(
                            "Expected field (String) '{}' not found",
                            key
                        )))
                    }
                }
            }
            Ok(MessagesDoc {
                _id: get__id(&obj, "_id")?,
                _creation_time: get__creation_time(&obj, "_creationTime")?,
                author: get_author(&obj, "author")?,
                body: get_body(&obj, "body")?,
            })
        }
    }
    impl FromConvexValue for MessagesDoc {
        fn from_convex(value: Value) -> Result<Self, ApiError> {
            MessagesDoc::try_from(value)
        }
    }
    impl MessagesDoc {
        pub fn to_convex_value(&self) -> Result<Value, ApiError> {
            let mut btmap = BTreeMap::new();
            btmap.insert("_id".to_string(), Value::from(self._id.clone()));
            btmap.insert(
                "_creation_time".to_string(),
                Value::from(self._creation_time),
            );
            btmap.insert("author".to_string(), Value::from(self.author.to_string()));
            btmap.insert("body".to_string(), Value::from(self.body.to_string()));
            Ok(Value::Object(btmap))
        }
    }
}
